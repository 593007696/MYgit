println(Mystr); //默认打印的是 Mystr.toString。所以要重写toString方法
public String toString() {
        return Str;
    }


    long st = System.currentTimeMillis();
        recursion(passWord, tryPassWord, 0);
        long et = System.currentTimeMillis();
        System.out.println("recursion spent " + (et - st) + "ms");
        计算时间



            public static char rand() {
        int a1 = (int) (Math.round(Math.random() * (122 - 97)) + 97);// a-z
        int a2 = (int) (Math.round(Math.random() * (90 - 65)) + 65);// A-Z
        int a3 = (int) (Math.round(Math.random() * (57 - 48)) + 48);// 0-9
        int oneOfThem = (int) Math.round(Math.random() * 2);// 随机决定a1,a2,a3中的一个

        if (oneOfThem == 0) {
            return (char) a1;
        } else if (oneOfThem == 1) {
            return (char) a2;
        } else {
            return (char) a3;
        }
    }

    public static char[] nketarand(int keta) {
        char cs[] = new char[keta];
        for (int i = 0; i < cs.length; i++) {
            cs[i] = rand();
        }

        return cs;

    }

    public static String strrand(int keta) {
        String str = "";
        for (int i = 0; i < nketarand(keta).length; i++) {
            str += nketarand(keta)[i];
        }
        return str;

    }

    所有的数据类型，无论是整数，布尔，浮点数还是字符串，最后都需要以数字的形式表现出来。

日期类型也不例外，换句话说，一个日期，比如2020年10月1日，在计算机里，会用一个数字来代替。

那么最特殊的一个数字，就是零. 零这个数字，就代表Java中的时间原点，其对应的日期是1970年1月1日 8点0分0秒 。 (为什么是8点，因为中国的太平洋时区是UTC-8，刚好和格林威治时间差8个小时)

为什么对应1970年呢？ 因为1969年发布了第一个 UNIX 版本：AT&T，综合考虑，当时就把1970年当做了时间原点。

所有的日期，都是以为这个0点为基准，每过一毫秒，就+1。

日本就是9点

getTime() 得到一个long型的整数



当前日期的毫秒数
new Date().getTime() 和 System.currentTimeMillis() 是一样的
不过由于机器性能的原因，可能会相差几十毫秒，毕竟每执行一行代码，都是需要时间的

