1.将可能抛出FileNotFoundException 文件不存在异常的代码放在try里
2.如果文件存在，就会顺序往下执行，并且不执行catch块中的代码
3. 如果文件不存在，try 里的代码会立即终止，程序流程会运行到对应的catch块中
4. e.printStackTrace(); 会打印出方法的调用痕迹，
如此例，会打印出异常开始于TestException的第16行，这样就便于定位和分析到底哪里出了异常

有的时候一段代码会抛出多种异常，比如
 
new FileInputStream(f);
Date d = sdf.parse("2016-06-03");
 

这段代码，会抛出 文件不存在异常 FileNotFoundException 和 解析异常ParseException
解决办法之一是分别进行catch
 
catch (FileNotFoundException e) {
    System.out.println("d:/LOL.exe不存在");
    e.printStackTrace();
} catch (ParseException e) {
    System.out.println("日期格式解析错误");
    e.printStackTrace();
}

另一个种办法是把多个异常，放在一个catch里统一捕捉
 
catch (FileNotFoundException | ParseException e) {
 

这种方式从 JDK7开始支持，好处是捕捉的代码更紧凑，不足之处是，一旦发生异常，不能确定到底是哪种异常，需要通过instanceof 进行判断具体的异常类型
 
if (e instanceof FileNotFoundException)
	System.out.println("d:/LOL.exe不存在");
if (e instanceof ParseException)
	System.out.println("日期格式解析错误");

    无论是否出现异常，finally中的代码都会被执行

    hrows与throw这两个关键字接近，不过意义不一样，有如下区别：
1. throws 出现在方法声明上，而throw通常都出现在方法体内。
2. throws 表示出现异常的一种可能性，
并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某个异常对象。
异常分类： 可查异常，运行时异常和错误3种
其中，运行时异常和错误又叫非可查异常


运行时异常RuntimeException指： 不是必须进行try catch的异常
常见运行时异常:
除数不能为0异常:ArithmeticException
下标越界异常:ArrayIndexOutOfBoundsException
空指针异常:NullPointerException
在编写代码的时候，依然可以使用try catch throws进行处理，与可查异常不同之处在于，即便不进行try catch，也不会有编译错误
Java之所以会设计运行时异常的原因之一，是因为下标越界，空指针这些运行时异常太过于普遍，如果都需要进行捕捉，代码的可读性就会变得很糟糕。