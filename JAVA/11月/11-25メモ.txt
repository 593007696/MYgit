所有的子类转换为父类，都是说得通的。
父类转子类，有的时候行，有的时候不行，
所以必须进行强制转换。
Hero h =new Hero();
1.        Hero h =new Hero();
2.        ADHero ad = new ADHero();
3.        h = ad;
4.        ad = (ADHero) h;
第3行，是子类转父类，一定可以的
第4行，就是父类转子类，所以要进行强转。
h这个引用，所指向的对象是ADHero, 
所以第4行，就会把ADHero转换为ADHero，
就能转换成功。
1.        Hero h =new Hero();
2.        ADHero ad = new ADHero();
3.        Support s =new Support();
4.        h = s;
5.        ad = (ADHero)h;
第4行，是子类转父类，是可以转换成功的
第5行，是把h引用所指向的对象 Support，
转换为ad引用的类型ADHero。 从语义上讲，
把物理攻击英雄，当成辅助英雄来用，说不通，
所以会强制转换失败，并且抛出异常

没有继承关系的两个类，互相转换，一定会失败
虽然ADHero和APHero都继承了Hero，但是彼此没有互相继承关系
"把魔法英雄当做物理英雄来用",在语义上也是说不通的

インターフェース」は異なる種類のものを結びつける共用部分という意味


instanceof Hero 判断一个引用所指向的对象，是否是Hero类型，或者Hero的子类


@Override是伪代码,表示重写。(当然不写@Override也可以)，不过写上有如下好处: 
1、可以当注释用,方便阅读；
2、编译器可以给你验证@Override下面的方法名是否是你父类中所有的，如果没有则报错。例如，你如果没写@Override，
而你下面的方法名又写错了，
这时你的编译器是可以编译通过的，
因为编译器以为这个方法是你的子类中自己增加的方法。


实例化子类，父类的构造方法一定会被调用顶

子类父类都有的属性 通过super来调用父类属性


声明一个类的时候，默认是继承了Object

当类被修饰成final的时候，表示类不能够被继承
其子类会出现编译错误

fulei的方法被修饰成final,那么该方法在子类中，不能够被重写
final修饰变量后变量只能被赋值一次

string类不可继承 因为string类被final修饰

abstract 修饰类为抽象类 
一旦一个类被声明为抽象类，就不能够被直接实例化

区别1：
子类只能继承一个抽象类，不能继承多个
子类可以实现多个接口
区别2：
抽象类可以定义
public,protected,package,private
静态和非静态属性
final和非final属性
但是接口中声明的属性，只能是
public
静态
final的
即便没有显式的声明
